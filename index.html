<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snoop Lanche Tech</title>
    <style>
        body { margin: 0; padding: 0; background: black; overflow: hidden; color: cyan; font-family: monospace; }
        #app { display: flex; flex-direction: column; height: 100vh; }
        #header { padding: 10px; text-align: left; }
        #main { flex: 1; display: flex; justify-content: center; align-items: center; position: relative; }
        canvas { display: block; }
        #video-container { position: absolute; bottom: 10px; right: 10px; width: 150px; height: 112px; border: 1px solid cyan; }
        video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
    </style>
</head>
<body>
    <div id="app">
        <div id="header">
            SNOOP TECH // GESTURE_CONTROL_v2.0
        </div>
        <div id="main">
            <div id="video-container">
                <video id="webcam" autoplay playsinline></video>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>

    <script>
        // Configuração da câmera
        const videoElement = document.getElementById('webcam');
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        camera.start();

        // Configuração do Three.js
        const scene = new THREE.Scene();
        const camera3d = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('main').appendChild(renderer.domElement);

        camera3d.position.z = 5;

        // Criar a esfera de partículas (igual à sua referência)
        const particleCount = 5000;
        const particlesGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const sphereRadius = 2.5;

        for (let i = 0; i < particleCount; i++) {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = sphereRadius;
            positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i * 3 + 2] = r * Math.cos(phi);
        }
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const particlesMaterial = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.02 });
        const particleSphere = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particleSphere);

        // Criar a malha da mão geometrica (nítida, igual à imagem)
        const handGroup = new THREE.Group();
        scene.add(handGroup);

        const landmarksCount = 21;
        const landmarksMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const connectionsMaterial = new THREE.LineBasicMaterial({ color: 0x00aaff, linewidth: 1 }); // Linhas azuis nítidas

        // Conexões da mão definidas pelo MediaPipe
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4], // Polegar
            [0, 5], [5, 6], [6, 7], [7, 8], // Indicador
            [5, 9], [9, 10], [10, 11], [11, 12], // Médio
            [9, 13], [13, 14], [14, 15], [15, 16], // Anelar
            [13, 17], [17, 18], [18, 19], [19, 20], // Mínimo
            [0, 17] // Pulso
        ];

        for (let i = 0; i < landmarksCount; i++) {
            const geometry = new THREE.IcosahedronGeometry(0.05, 0); // Pontos geométricos
            const landmarkMesh = new THREE.Mesh(geometry, landmarksMaterial);
            landmarkMesh.name = `landmark_${i}`;
            handGroup.add(landmarkMesh);
        }

        const linesGroup = new THREE.Group();
        handGroup.add(linesGroup);

        // Função de detecção de mãos
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        function onResults(results) {
            // Limpar linhas antigas
            linesGroup.children.forEach(child => child.geometry.dispose());
            linesGroup.clear();

            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    // Atualizar pontos brancos (flutuantes da image_3.png) - mantendo para mostrar sua lógica, mas eles agora se movem com a mão
                    // landmarksMaterial.color.setHex(0xffffff); // Pontos brancos flutuantes

                    // Atualizar a malha geométrica (para ficar idêntico à imagem desejada)
                    // Configurar a cor dos pontos para ciano (image_1.png)
                    landmarksMaterial.color.setHex(0x00ffff);

                    for (let i = 0; i < landmarksCount; i++) {
                        const landmarkMesh = handGroup.getObjectByName(`landmark_${i}`);
                        const landmark = landmarks[i];
                        landmarkMesh.position.x = (landmark.x - 0.5) * 8;
                        landmarkMesh.position.y = -(landmark.y - 0.5) * 6;
                        landmarkMesh.position.z = -landmark.z * 5; // Adicionar profundidade
                    }

                    // Desenhar conexões de malha geométrica nítida (image_1.png)
                    for (const connection of HAND_CONNECTIONS) {
                        const start = handGroup.getObjectByName(`landmark_${connection[0]}`).position;
                        const end = handGroup.getObjectByName(`landmark_${connection[1]}`).position;
                        const points = [start, end];
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                        const line = new THREE.Line(lineGeometry, connectionsMaterial);
                        linesGroup.add(line);
                    }
                }
            } else {
                // Esconder a mão se não houver landmarks
                handGroup.children.forEach(child => {
                    if (child.name.startsWith('landmark')) {
                        child.visible = false;
                    }
                });
            }
        }

        // Loop de renderização
        function animate() {
            requestAnimationFrame(animate);
            // Rotacionar lentamente a esfera de partículas
            particleSphere.rotation.y += 0.001;
            renderer.render(scene, camera3d);
        }
        animate();

        // Ajustar redimensionamento
        window.addEventListener('resize', () => {
            camera3d.aspect = window.innerWidth / window.innerHeight;
            camera3d.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>

