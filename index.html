<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snoop Tech - Interface Holográfica</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Inter', sans-serif; }
        #startBtn {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            padding: 18px 40px; background: transparent; color: #00f2ff;
            border: 2px solid #00f2ff; border-radius: 4px; font-weight: bold; 
            cursor: pointer; z-index: 100; text-transform: uppercase;
            letter-spacing: 2px; transition: 0.3s;
        }
        #startBtn:hover { background: #00f2ff; color: #000; box-shadow: 0 0 30px #00f2ff; }
        #ui-layer {
            position: fixed; top: 20px; left: 20px; color: #00f2ff;
            font-size: 10px; letter-spacing: 2px; opacity: 0.7;
        }
    </style>
</head>
<body>

<div id="ui-layer">SNOOP TECH // GESTURE_CONTROL_v2.0</div>
<button id="startBtn">CONECTAR INTERFACE</button>
<video id="video" style="display:none;" autoplay playsinline></video>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
    // --- CENA THREE.JS ---
    const scene = new THREE.Scene();
    const camera3D = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- GLOBO DE PARTÍCULAS ---
    const particleCount = 3500;
    const geo = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const originPos = new Float32Array(particleCount * 3);

    for (let i = 0; i < particleCount; i++) {
        const r = 1.4;
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);

        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);

        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;
        originPos[i * 3] = x;
        originPos[i * 3 + 1] = y;
        originPos[i * 3 + 2] = z;
    }

    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const globe = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0x00f2ff, size: 0.018 }));
    scene.add(globe);

    // --- MÃO PEQUENA E DISCRETA ---
    const handGroup = new THREE.Group();
    scene.add(handGroup);

    const joints = [];
    // Juntas menores (0.02) e brancas para parecer um sensor holográfico
    const jointGeo = new THREE.SphereGeometry(0.025, 8, 8); 
    const jointMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

    for (let i = 0; i < 21; i++) {
        const m = new THREE.Mesh(jointGeo, jointMat);
        joints.push(m);
        handGroup.add(m);
    }

    camera3D.position.z = 5;

    // --- LOGICA DE MOVIMENTO E EXPLOSÃO ---
    let explosion = 1.0;
    let targetExplosion = 1.0;

    const hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.75,
        minTrackingConfidence: 0.75
    });

    hands.onResults(results => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const pts = results.multiHandLandmarks[0];

            pts.forEach((p, i) => {
                // CORREÇÃO DE ESPELHAMENTO: -(p.x - 0.5) inverte o eixo X
                // REDUÇÃO DE TAMANHO: Multiplicado por 6 e 5 em vez de 12 e 9
                const x = -(p.x - 0.5) * 6; 
                const y = -(p.y - 0.5) * 5;
                const z = -p.z * 3;
                
                // Resposta mais rápida (0.8) para tirar o delay
                joints[i].position.lerp(new THREE.Vector3(x, y, z), 0.8);
            });

            // GESTO: Abre a mão = Explode | Fecha = Volta
            const dist = Math.hypot(pts[0].x - pts[12].x, pts[0].y - pts[12].y);
            targetExplosion = dist > 0.35 ? 2.8 : 1.0;
        }
    });

    function animate() {
        requestAnimationFrame(animate);

        explosion = THREE.MathUtils.lerp(explosion, targetExplosion, 0.15);

        const attr = globe.geometry.attributes.position;
        for (let i = 0; i < particleCount; i++) {
            attr.setXYZ(i, 
                originPos[i*3] * explosion, 
                originPos[i*3+1] * explosion, 
                originPos[i*3+2] * explosion
            );
        }
        attr.needsUpdate = true;
        
        globe.rotation.y += 0.003;
        renderer.render(scene, camera3D);
    }
    animate();

    // Resize
    window.addEventListener('resize', () => {
        camera3D.aspect = window.innerWidth / window.innerHeight;
        camera3D.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Iniciar Câmera
    const video = document.getElementById('video');
    document.getElementById("startBtn").onclick = function() {
        this.style.display = 'none';
        const cam = new Camera(video, {
            onFrame: async () => { await hands.send({ image: video }); },
            width: 1280, height: 720
        });
        cam.start();
    };
</script>

</body>
</html>
